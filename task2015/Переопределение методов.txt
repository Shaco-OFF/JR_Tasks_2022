Изменение протокола по умолчанию
Давайте перейдем ко второму способу реализации сериализации: изменение протокола по умолчанию. Хотя в анимационном коде,
рассмотренном выше, был показан способ использования потока с объектом, обеспечив при этом его сериализацию, для того
чтобы понять суть проблемы нужно разобраться в том, каким образом Java создает объекты. Задумайтесь, когда мы создаем
объект при помощи ключевого слова new, конструктор объекта вызывается только при создании нового экземпляра объекта.
Запомним этот факт и вновь взглянем на наш анимационный код. Сначала мы создаем экземпляр объекта PersistentAnimation,
который запускает поток анимации. Затем мы сериализуем его при помощи кода:

PersistentAnimation animation = new PersistentAnimation(10);
FileOutputStream fos = ...
ObjectOutputStream out = new ObjectOutputStream(fos);
out.writeObject(animation);
Все кажется в порядке, но только до тех пор, пока мы не прочитаем объект используя вызов метода readObject(). Помните,
конструктор вызывается только при создании нового экземпляра объекта. Здесь же мы не создаем нового экземпляра, мы просто
восстанавливаем сохраненный объект. В результате анимационный объект отработает лишь однажды, при первом создании
экземпляра этого объекта, что делает процесс его сохранения бессмысленным, не так ли?

Что же, есть и хорошая новость. Мы можем заставить наш объект работать так, как нам хочется, перезапуская анимацию при
восстановлении объекта. Чтобы сделать это мы можем, например, создать вспомогательный метод startAnimation(), выполняющий
те же функции, что и наш конструктор. Затем мы можем вызывать этот метод из конструктора, после каждой загрузки объекта.
Неплохо, но несколько сложно. Теперь все, кто захочет использовать анимационный объект, должны знать о необходимости вызова
этого метода после обычного процесса десериализации, что никак не вписывается в тот единообразный механизм, который
Java Serialization API обещает разработчикам.

Однако, существует другое странное и хитрое решение. Используя встроенную возможность механизма сериализации, разработчики
могут реализовать нормальный процесс поместив в свои файлы классов два метода:

private void writeObject(ObjectOutputStream out) throws IOException;
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException;
Обратите внимание, что оба метода (совершенно справедливо), объявлены как private, поскольку это гарантирует что методы не
будут переопределены или перезагружены. Весь фокус в том, что виртуальная машина при вызове соответствующего метода
автоматически проверяет, не были ли они объявлены в классе объекта. Виртуальная машина в любое время может вызвать private
методы вашего класса, но другие объекты этого сделать не смогут. Таким образом обеспечивается целостность класса и
нормальная работа протокол сериализации. Протокол сериализации всегда используется одинаково, путем вызова
ObjectOutputStream.writeObject() или ObjectInputStream.readObject(). Таким образом, даже если в классе присутствуют эти
специализированные private методы, сериализация объектов будет работать так же, как и для любых других вызываемых объектов.

Учитывая это, давайте взглянем на исправленную версию PersistentAnimation, в которую включены эти private методы для
контроля над процессом десериализации через псевдо-конструктор:

10  import java.io.Serializable;
20  public class PersistentAnimation implements Serializable, Runnable
30  {
40    transient private Thread animator;
50    private int animationSpeed;
60    public PersistentAnimation(int animationSpeed)
70    {
80      this.animationSpeed = animationSpeed;
90      startAnimation();
100   }
110       public void run()
120   {
130     while(true)
140     {
150       // do animation here
160     }
170   }
180   private void writeObject(ObjectOutputStream out) throws IOException
190   {
200     out.defaultWriteObject();
220   }
230   private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
240   {
250     // наш "псевдо-конструктор"
260     in.defaultReadObject();
270     // теперь мы вновь получили "живой" объект, поэтому давайте перестроим и запустим его
280     startAnimation();
290
300   }
310   private void startAnimation()
320   {
330     animator = new Thread(this);
340     animator.start();
350   }
360 }
Обратите внимание на первые строки новых private методов. Эти вызовы выполняют операции, созвучные их названию -
они выполняют по умолчанию запись и чтение разложенных объектов, что важно, поскольку мы не заменяем нормальный процесс,
а лишь дополняем его. Эти методы работают, потому что вызов ObjectOutputStream.writeObject() соответствует протоколу
сериализации. Сначала объект проверяется на реализацию Serializable, а затем проверяется на наличие этих private методов.
Если они есть, им в качестве параметра передается класс потока, через использование которого осуществляется управление кодом.

Эти private методы могут использоваться для внесения любого рода изменений в процесс сериализации.
Например, для вывода объектов в поток может быть использована шифровка, а для ввода - дешифровка (при записи и чтении
байтов данные записываются даже без применения технологии запутывания (obfuscation)). Методы могут использоваться также
для сохранения в потоке дополнительных данных, например кода версии. Ваши возможности поистине не ограничены.